---
output: rmarkdown::github_document
---
<table style="width:100%;">
  <tr>
    <td style="text-align:left; vertical-align:middle;">
      <h1 style="margin:0;">MUSC</h1>
      <p style="margin:0.25rem 0 0;">
        <strong>Authors:</strong> Chloe mattila, Elizabeth Hill, Brian Neelon, and Souvik Seal
      </p>
    </td>
    <td style="text-align:right; width:1%; white-space:nowrap;">
      <!-- invisible spacer: keeps layout, not visible -->
      <span aria-hidden="true"
            style="display:inline-block; width:140px; height:150px; opacity:0;"></span>
      <!-- later: <img src="MUSC_logo.png" alt="MUSC logo" style="height:150px; width:auto;"> -->
    </td>
  </tr>
</table>

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#",
  out.width = "100%",
  messages = FALSE,
  warnings = FALSE
)
```

The *R* package implements the models proposed in the manuscript "MUSC: MUlti-level variable selection for Spatial Count data." It enables Bayesian variable selection for regression of negative binomial (overdispersed) spatially indexed count data with and without feature grouping using horseshoe, spike and slab, or when grouping the multi-level group extensions of horseshoe or spike and slab priors. It is easily applicable to broader spatial datasets, where the outcome is spatially indexed count data (e.g. State-level cancer incidence counts) with multiple features, and feature grouping (e.g. Population/ SES, Behavior, Smoking, etc).

## Install and load MUSC

We install and load the developmental version of MUSC from GitHub. 

```{r loading packages, message=FALSE}

# MUSC installation
devtools::install_github('Cmattila', quiet = TRUE, force = TRUE)
library(MUSC)


# # List of packages for Import
# library(svMisc); library(spam); library(MCMCpack);
# library(Matrix); library(spdep); library(BayesLogit);
# library(coda); library(bayestestR); library(ggplot2);
# library(dplyr); library(grid); library(stats);
# library(graphics); library(utils); library(rlang)
```


## Simulate mildly correlated feature data, $p=200$

Then we simulate $(p-1)=199$ features with a within group correlation of $\rho=0.25$.  For each non-null coefficient $\beta_j$, the signal magnitude was independently drawn from Unif(0.5, 2); all remaining coefficients, intercept included, were set to zero.We set the group size to $M_g = 5$, yielding $G = ⌈(p − 1)/M_g$⌉ groups, with all groups of size five except one, which had four, with the thress selected groups under Case 2 where within a group some features are active and some are inactive, have three, three and four active features.


```{r constructing phi, out.width = "50%"}
N <- 100 # number of observations/ spatial units
p <- 200 # number of features
signal_vec <- runif(10, min = 0.5, max = 2)

Mg = 5 # group size
G = p/Mg # number of groups
group_ind <- generate_group_ind(p, G) # group indicator

#generating the 
nonNull_indices_p200_Case2 <- generate_nonnull_indices(p, group_ind, num_nonnull = 10,
                                                        nonnull_group_structure = "Case2", per_group_nonnull = 3)

Null_indices_p200_Case2 <- setdiff(1:200, nonNull_indices_p200_Case2)  # Complement of nonNull indices

set.seed(2025)

Features <- feature_sim_grouped(N = N, p = p, group_ind = group_ind, 
                            nonNull_indices = nonNull_indices_p200_Case2, signal_vec = signal_vec)
```


## Construct the random effect $\phi$ and neighborhood list

We construct a $10 \times 10$ grid under a queen adjacency structure to simulate the spatial random effect, $\mathbf{\phi}$ with $\nu = 0.1$ with which $\mathbf{y}$ will be generated and the associated neighborhood list. 

```{r constructing feature matrix, out.width = "50%"}
# Create a 10x10 grid of coordinates since we have an N=100 and assuming no repeated measures
coords100 <- expand.grid(x = 1:10, y = 1:10)

# Create a neighborhood structure (using "queen" to classify neighbors as sharing edges and corners) 
nb100 <- cell2nb(10, 10, type = "queen") 

#visualizing neighborhood structure
plot(nb100,coords100) 
n_mat100 <- spdep::nb2mat(nb100, style = "B") #b indicates binary 0/1
Q100 <- diag(rowSums(n_mat100)) - n_mat100

## Simulating phi, iCAR spatial random effects
set.seed(2025)
phi <- phi_True_func(nu_vals=0.1, Q=Q100, n_space=100)
```


## Simulate the spatially indexed count data

Then we simulate $N=100$ outcomes with spatial index phi, simulated populations for each spatial unit, and a scale of per 100,000. 

```{r constructing outcome vector, out.width = "50%"}
nis <- rep(1,N) # assuming no repeated measures
scale = 100000
pop <- sample(10000:50000, N, TRUE)

 
yy <- y_gen_fun(N = N, r = 1, K = Features$K, beta_true = Features$beta_true, phi_true = phi$phi_nu_0.1, Scale = scale, pop_col = pop, offset = TRUE)
```


## Fit the HS or SS grouped varible selection models

The main function of "MUSC" fits negative binomial models using either the standard horseshoe prior (\texttt{which.prior = "HS"}) or spike and slab prior (\texttt{which.prior = "SS"}), or their grouped extensions (specifying the vector of group indicators; \texttt{group_ind}). Additionally, these models can be specified to include a spatial random effect (specifying the neighborhood list, an object of class \code{nb}; \texttt{NeighborhoodList}). $X$ denotes the matrix of spatial-unit-level features (dimension $N\times p-1$). \texttt{niter} denotes the number of MCMC iterations. \texttt{pop_col} is the vector of the population for each spatial unit and \texttt{scale} is the desired scale for the rates (i.e. per 100,000). Note, for SS with $p=200$, this will take a bit of time. 

```{r fitting SS grouped varible selection with offset and spatial random effect, out.width= "50%"}

SS_group_offset_space <- MUSC(X = Features$X,                 # feature matrix
                              y = yy$y,                        # outcome vector
                              group_ind =  group_ind,         # group indicator vector
                              NeighborhoodList = nb100,       # Neighborhood list
                              pop_col = pop,                  # vector of spatial unit populations
                              scale = scale,                  # rate scale
                              which.prior = "SS",             # method
                              niter = 10000)                  # MCMC iterations

print(str(SS_group_offset_space)) # check the returned list object
```


## MCMC convergence plots 

The above function returns a list of several objects, including a matrix of the post-burn-in posterior beta estimates, with dimension \texttt{niter} $\times p$. We randomly select 4 betas and plot their convergence. 

```{r MCMC diagnostic plots, out.width= "50%"}
set.seed(2025)

ran_sam = sample(1:N, 4)
par(mfrow = c(2, 2))
MCMC_plot(SS_group_offset_space$Beta[, (ran_sam[1])], main = "beta 13")
MCMC_plot(SS_group_offset_space$Beta[, (ran_sam[2])], main = "beta 76", col_trace = "blue")
MCMC_plot(SS_group_offset_space$Beta[, (ran_sam[3])], main = "beta 36", col_trace = "pink")
MCMC_plot(SS_group_offset_space$Beta[, (ran_sam[4])], main = "beta 26", col_trace = "gold")

```


## Visualize the posterior inclusion probablities (PIP)

Display the posterior inclusion probability of each beta with a selection threshold of $0.75$. 

```{r PIP visualization, out.width= "50%"}
post_means <- colMeans(SS_group_offset_space$pDelta)
selected <- as.numeric(post_means > 0.75)
tp <- sum(selected[nonNull_indices_p200_Case2]) # truly nonnulls detected 
fn <- length(nonNull_indices_p200_Case2) - tp   # truly nonnulls not detected
fp <- sum(selected[Null_indices_p200_Case2])    # truly null detected; nulls include intercept
tn <- length(Null_indices_p200_Case2) - fp      # truly null not detected; nulls include intercept



# predictors correspond to columns 2:p (since col 1 is the intercept)
predictors <- paste0("x", 1:(p - 1))              # keys for plotting
predictor_labels <- predictors                     # or swap in pretty labels if you have them

# Group labels: map each predictor to its group id (1..G)
# group_ind is length p-1, aligned to predictors
group_map <- setNames(paste0("Group ", group_ind), predictors)
group_levels <- paste0("Group ", sort(unique(group_ind)))  # order under x-axis

res <- plot_pdelta_bars_mcmc(
  predictors        = predictors,
  pdelta_mat        = SS_group_offset_space$pDelta[,-1],      # iterations × (p-1) matrix, removing the intercept column 
  outcome_name      = "SS (group, spatial, offset)",    # whatever label you want in the legend
  predictor_labels  = predictor_labels,          # pretty x-axis labels (optional)
  group_map         = group_map,                 # bands under x-axis (optional)
  group_levels      = group_levels,              # order of bands (required if using groups)
  use_groups        = TRUE,
  x_order           = "group",                   # "group" to sort by bands, else "given"
  thresholds        = c(0.75),               # reference lines
  legend_title      = "Model/Outcome",
  colors            = "steelblue",               # single outcome → one color
  base_size         = 20
)

print(res$plot)
```


